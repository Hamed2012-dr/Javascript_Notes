# Async **JavaScript** Promises & Callbacks

- **JavaScript** is single-threaded. It means that **JavaScript** can only execute one task at a time. Consider this code:

    ```js
    console.log(..);
    someFunction();
    button.disabled = true;
    moreCode();
    ```

    All these steps run in sequence after each other. They're not running simultaneously next to each other, instead **JavaScript** will log something to the console, then call the function and do whatever needs to be done inside of that function, then go ahead and disable that button and then call that other function, so these things happen after each other, not at the same time. Now consider:

    ```js
    console.log(..);
    setTimeout(someFunction, 5000);
    moreCode();
    ```

    The problem is `setTimeout(..)` might take 2 seconds, 5 seconds, 10 seconds or maybe just 100 miliseconds, but even 100 miliseconds would be a duration we probably would not want to wait, because this operation could in general take longer and therefore block our code execution. So it prevents more code from being executed until `setTimeout(..)` is done. At least, if **JavaScript** would treat this in the same way as it would treat all other code blocks. Typically you don't want to block your entire script until these operations finish, because blocking your script would not just mean that the next line doesn't execute immediately, it would also mean that no other code can execute. Thankfully **JavaScript** and browsers have a solution for that. You have asynchronous code execution. The browser takes care of these tasks, manages them in multiple threads and therefore our **JavaScript** code is not blocked. Now the browser however needs a way for it to communicate back to our **JavaScript** code and for that, we typically use **callback** functions. For example:

    ```js
    const button = document.querySelector("button");

    function trackUserHandler() {
        console.log("Clicked!");
    }

    button.addEventListener("click", trackUserHandler);
    // === User clicked on the button ===
    // Clicked
    ```

- The **event loop** helps us deal with async code. It helps us deal with callback functions which typically are used in such async code scenarios. Consider:

    ```js
    const greet = () => {
        console.log("Hi");
    };

    const showAlert = () => {
        alert("Danger!");
    };

    setTimeout(showAlert, 2000);
    greet();
    ```

    We need some way of telling our **JavaScript Engine** that the `showAlert()` function (which was register as a callback for the timer) should be executed. For this, a **message queue** is used. This is provided by the browser and it's also linked to **JavaScript**. In this message queue, the browser registers any code that should execute once we have time for it (in this case, the timer). So the `showAlert()` function is registered as a to-do task once the **JavaScript Engine** has time for it. The event loop is not part of the **JavaScript Engine**, it's really part of the host environment of **JavaScript**. The job of the event loop in the end is to synchronize the call stack in the engine with our waiting messages.
