# Working with the DOM (Browser HTML Code) in **JavaScript**

- We all know that the **JavaScript** can interact with the browser (with rendered HTML code). In the end that's called DOM (**D**ocumnet **O**bject **M**odel). In **JavaScript**, there are certain methods that allows us to reach out to the loaded HTML code. For example:

    ```js
    const el = document.querySelector("h1"); // to get `h1` tag from the browser
    ```

- DOM is not strictly tied to browsers. There are other tools that can parse HTML.
- The `document` object (it's a global object that all the browsers provides it) is the topmost entry point to get access to all that rendered HTML code. `document` provides you various methods and functionalities to get access to the elements, to query for elements, to query for HTML elements, to interact with DOM contents, so to interact with loaded HTML code.
- The `window` object (it's a global object that all the browsers provides it) gives you access to all the features that the browser want to expose to you. It acts as global storage for script, also provides access to window-specific properties and methods.
- You can see all properties and methods inside the `document` and `window` objects by putting them in `console.dir(..)` function. For example:

    ```js
    console.dir(window); // it have too many properties and methods
    ```

- The browser always looks in the `window` object if you're calling or accessing something that can't be found anywhere else. Whilst it's called window, it really just means the currently loaded tab (not other tabs). For example:

    ```js
    alert("Hamed"); // it's actually `window.alert("Hamed")`
    document.getElementById("Hamed"); // it's actually `window.document.getElementById("Hamed")`
    ```

- After parsing HTML code, all tags will be stored in the memory, and you can access them. These tags are called **elemenet Node**. Not just HTML tags are loaded and created as objects, but also all text that you have, and these are created as so-called **Text Nodes**.
- You can get access to single elements from DOM with `querySelector(..)` and `getElementById(..)`. The `querySelector(..)` takes a CSS selector (even pseudo selectors are supported) and it gives you therefore a lot of flexibility and power when it comes to selecting elements with complex query in your DOM (it returns the first selected element). The `getElementById(..)` on the other hand takes an ID which you might have assigned to an HTML element and selects an element by that and since ID should be unique on your web page, because this is a method which returns one element. DOM Nodes are just **JavaScript** objects in the end (i.e. reference values). These methods return the object references (addresses).
- The `querySelectorAll(..)`, `getElementsByTagName(..)`, and etc, returns a collection of elements (array-like objects), typically a Nodelist. You have different ways of querying elements (e.g. by CSS selector, by tag name, by CSS class, and etc).
- Everything in the DOM is a Node. Elements are really just the Nodes which are created of HTML tags which were rendered, not the text in there. There are special properties and methods to interact with the elements. Available methods and properties depend on the kind of element. They can be created and removed via **JavaScript**. Consider:

    ```html
    <!DOCTYPE html>
    <html lang="en">

    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>DOM</title>
    <script src="app.js" defer></script>
    </head>

    <body>
    <h1 class="main-title">It's Hamed</h1>
    </body>

    </html>
    ```

    Let's get (and manipulate) some information from this HTML:

    ```js
    const h1 = document.querySelector("h1");

    console.log(h1.textContent); // It's Hamed
    console.log(h1.className); // ""
    h1.textContent = "Some new text!";
    console.log(h1.textContent); // Some new text!
    h1.style.color = "white";
    h1.style.backgroundColor = "black";
    ```

    You can access all CSS properies with `style` property. In **JavaScript**, `background-color` (for exmaple) is not a valid property name and you must not have dashes (`-`) in there, so instead all the CSS property names that have a dash in there are translated to **JavaScript** property names (which is generally the same), but where the dash is removed and to make it more readable therefore, the first character after the dash is replaced with a capital character. So `background-color` becomes `backgroundColor`.
- Whatever you change **JavaScript** code in the broswers console will be lost whenever you reload the page, because what you do in **JavaScript** is only stored in memory. It is of course doesn't affect the underlying files which were loaded (which typically lie on some server one the internet).
- The attribute is the thing in your HTML code (HTML text in the end). The property is a value stored in the object that's created based on your HTML code. Objects in **JavaScript** have properties, no matter if there are some DOM objects or not. The idea of attributes is, if your're writing HTML code, can provide a certain default configuration to this to be created DOM object. Not always the attribute name is equal to property name (e.g. `className` property for `class` attribute).
- You can change an attribute with `setAttribute(..)` method and it takes two arguments, the first one is the name of attribute (it should be a `string`) and second is the value you want to assign to that attribute. You can also get the attribute value with `getAttribute(..)` method. For example:

    ```js
    const input = document.getElementById("input-one");

    input.setAttribute("value", "some other default text");
    input.value = getAttribute("value");
    ```

- The number of items in the array will not change if you add or remove elements with `querySelectorAll(..)`, because that just takes a snapshot.
- You can take an element which you already did select and then move its children or its siblings based on that element. That's what's **traversing the DOM** means.
- In **JavaScript**, a **child** element means a direct child Node or an element. Consider:

    ```html
    <div>
      <p>
        A <em>test</em>
      </p>
    </div>
    ```

    The `<p>` tag is a child of `<div>`, because it's a direct child element. The `<em>` tag however isn't, because whilst the `<em>` tag is still kind of nested inside of `<div>` tag, it's not a direct child.
- In **JavaScript**, a **descendant** element means a direct or indirect child Node or element. Consider:

    ```html
    <div>
      <p>
        A <em>test</em>
      </p>
    </div>
    ```

    Here the `<p>` tag and the `<em>` tag are descendants of `<div>` tag.
- In **JavaScript**, a **parent** Node or element is the direct parent Node or element of another elements. Consider:

    ```html
    <div>
      <p>
        A <em>test</em>
      </p>
    </div>
    ```

    Here the `<div>` is a parent of the `</p>` tag, but not of `<em>`.
- In **JavaScript**, an **ancestor** Node or element is a direct or indirect parent Node or element of another elements. Consider:

    ```html
    <div>
      <p>
        A <em>test</em>
      </p>
    </div>
    ```

    Here we have `<div>` tag as an ancestor of both the `<p>` tag and the `<em>` tag.
- You can get the children of an element with `children` property. It will return a `HTMLCollection`. Consider you have an `<ul>` tag with 3 children (e.g. `<li>`):

    ```js
    const ul = document.querySelector("ul");

    console.log(ul.childern);
    /*
    HTMLCollection(3)
    0: li
    1: li
    2: li
    length: 3
    __proto__: HTMLCollection
    */
    ```

    The `children` property always return the child element Nodes. If you want to get all Nodes (element and text), you sould use `childNodes` property. It will return a `NodeList`. For example:

    ```js
    const ul = document.querySelector("ul");

    console.log(ul.childNodes);
    /*
    NodeList(7)
    0: text
    1: li
    2: text
    3: li
    4: text
    5: li
    6: text
    length: 7
    __proto__: NodeList
    */
    ```

    You can also get the first and the last child of an element by using `firstElementChild` and `lastElementChild`. For example:

    ```js
    const ul = document.querySelector("ul");

    console.log(ul.lastElementChild); // <li>item 3</li>
    ```

    If you want to get the first and the last Node (element and text), you should use the `firstChild` and the `lastChild` properties.
- You can access to elements parent with `parentElement` property. Every element have just only one parent. For example:

    ```js
    const ul = document.getElementById("ul");

    console.log(ul.parentElement); // <body> .. </body>
    ```

- You can select any nearest ancestor anywhere up in the element tree with `closest(..)` method. For example:

    ```js
    const li = document.querySelector("li");

    console.log(li.closest("body")); // <body> .. </body>
    console.log(li.closest("header")); // null
    ```

- You can select the next sibling and the previous sibling of an element with `nextElementSibling` and `previousElementSibling` properties. The `previousSibling` property gives us the previous sibling Node (e.g. text Node) and the `nextSibling` property gives us the next sibling Node. For example:

    ```js
    const body = document.querySelector("body");

    console.log(body.previousElementSibling); // <head> .. </head>
    ```

- Deeply nested traversal logic will most likely also not yield any performance benefit or even perfom worse. So use `querySelector(..)` or methods like that in appropriate situations.
