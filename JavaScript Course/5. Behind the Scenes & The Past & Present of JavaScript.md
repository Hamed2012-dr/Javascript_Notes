# Behind the Scenes & The (Weird) Past (ES3, ES5) & Present (ES6+) of JavaScript

- ES stands for **E**CMA**S**cript. Over time, ECMAScript and therefore **JavaScript** evolved, it dates back into the 90s of course when it got started.
- ES6 was a major mark in development of **JavaScript**. Many new features added that help us to write cleaner, better, and faster code. **JavaScript** is still under active development, but ES6 was a big step step forward.
- All the modern browsers (includes Edge) have an auto updating functionality which means people don't have to manually install new browser versions, which was the case with older versions of Internet Explorer and therefor features can be integrated into browsers at a much faster pace and more and more users will automatically use these latest versions of browsers, because the browsers themselves automatically update, so that's really cool.
- If you declare two or more variables with the same name using `var` (pre-ES6), the latest variable will override all previous ones. For example:

    ```js
    var name = "Hamed";
    var name = "Hamid";
    var name = "Ali";

    console.log(name); // Ali
    ```

    As of ES6, if you try this with `let` keyword (or `const`), you will get an error. For example:

    ```js
    let name = "Hamed";
    let name = "Hamid"; // error happens here
    let name = "Ali";

    console.log(name); // SyntaxError: Identifier 'name' has already been declared
    ```

- In **JavaScript** with `let` and `const` you can define variables or constants in global scope or local scope (block scope) and use them in their own scope. But with `var`, (pre-ES6) variables are accessible entire the function scope. In other words, `var` only knows global scope and function scope, but `let` and `const` knows curly braces (blocks). For example:

    ```js
    // with `var`
    function greet() {
        if (true) {
            var name = "Hamed";
        }
        console.log("Hello " + name);
    }

    greet(); // Hello Hamed
    ```

    As of ES6, you can use `let` and `const` for block scoping:

    ```js
    function greet() {
        if (true) {
            let name = "Hamed";
            const AGE = 23;
        }
        console.log("Hello " + name, age);
    }

    greet(); // ReferenceError: name is not defined
    ```

    So **don't** use `var` anymore.

- In **JavaScript**, if you have a global variable and a local variable with the same name (or constants), **JavaScript Engine** will look at the nearest variable and take its value. It's called **shadowing**. For example:

    ```js
    let name = "Ali";

    function greet() {
        let name = "Hamed";
        console.log("Hello " + name);
    }

    greet(); // Hello Hamed
    ```

- **JavaScript** has a special feature called **hoisting** which means that the **JavaScript Engine** declares the variables (also functions) first, then initialize them. So if you try to define some variables after their calls, you will get `undefined` value. Consider:

    ```js
    console.log(name); // undefined

    var name = "Hamed"
    ```

    Why? because **JavaScript Engine** will interprets this snippet like this:

    ```js
    var name;

    console.log(name); // undefined
    name = "Hamed";
    ```

    But with `let` and `const`, **JavaScript** will force you to write cleaner and understandable code. So the **JavaScript Engine** throws an error if you try to hoisting variables (or constants) with `let` and `const`. For example:

    ```js
    console.log(name); // ReferenceError: Cannot access 'name' before initialization

    let name = "Hamed";
    ```

    It's good to take advantage of this feature for functions. For example:

    ```js
    greet("Hamed");

    function greet(name) {
        console.log(name);
    }
    ```
